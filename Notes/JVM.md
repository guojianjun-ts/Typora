# JVM

## Java 内存结构

​	JVM 在执行 Java 程序时，会把它管理的内存划分为若干个不同的数据区域。

### 运行时数据区域

1. **线程私有**：程序计数器、虚拟机栈、本地方法栈
2. **线程共享**：堆、方法区（JDK 8+ 称为元空间）
3. **直接内存**（不属于 JVM 运行时数据区，但影响 JVM 内存管理）

#### 1.程序计数器

- 线程私有，用于支持程序的流程控制和线程切换，仅存储当前线程的字节码指令。
- 执行方法不同，计数器的值也会不同：
  - 执行 Java 方法，计数器记录的是正在执行的虚拟机字节码指令。
  - 执行 native 方法，计数器的值会为空。
- 程序计数器是唯一不会OOM的区域，因为：
  - 空间固定（仅存储指令地址）
  - 生命周期随线程创建/销毁自动管理

#### 2.虚拟机栈

- 线程私有，用于支持 Java 方法的调用，每一个方法的调用和结束，都有着栈帧的压入和弹出。

- 栈(FILO)是由一个个栈帧所组成的，栈帧是方法调用的基本单位，栈帧的结构如下：

  - 局部变量表：使用 Slot（变量槽）为存储单位

    - 存储方法参数(基础数据类型或引用类型)

    - 方法内部定义的局部变量

      | Slot 0 | Slot 1 |       Slot 2-3       | Slot 4 | Slot 5 | Slot 6 |
      | :----: | :----: | :------------------: | :----: | :----: | :----: |
      | `this` |  `a`   | `b` (long 占 2 Slot) | `obj`  |  `x`   |  `s`   |

  - 操作数栈：

    - 用于计算和存储临时数据（类似 CPU 的寄存器）

  - 动态链接：

    - 用于解析方法的调用和访问字段，存储指向运行时常量池的引用。

  - 方法返回地址：

    - 存储方法执行完毕后的返回位置

- **可能抛出 `StackOverflowError`（栈深度超出）或 `OutOfMemoryError`（无法扩展栈空间）**。

#### 3.本地方法栈

- 线程私有，用于支持 Native 方法的调用。
- 方法调用时，也会创建栈帧，和虚拟机栈类似。
- **可能抛出 `StackOverflowError`（栈深度超出）或 `OutOfMemoryError`（无法扩展栈空间）**。

#### 4.Java 堆

- 线程共享，是 JVM 所管理的内存中最大的一块，存放几乎所有的对象实例和数组(逃逸分析可能导致对象栈上分配)，是 GC 的主要区域。

- 分代管理（JDK 8 及之前）

  - 新生代：
    - Eden，内置了本地线程分配缓冲区（TLAB）：线程私有，提升对象分配时的效率
    -  Survivor (S0/S1)
  - 老年代
  - 永久代(JDK 7 及之前) / 元空间(JDK8+)（不在JVM 内存区域中）

- 分配过程：

  ​	大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。

- 可能爆出 OOM 错误

##### 	4.1 字符串常量池

- JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。
- JDK 6 及之前，存放在永久代。由于永久代的GC回收效率太低了，只有Full GC 的时候才会被执行GC，为了高效及时的回收字符串内存，决定在JDK 7中，将字符串常量池和静态变量存放在 Java 堆中。

#### 5.方法区

- 线程共享，存储已被虚拟机加载的 类型信息、运行时常量池、静态变量、JIT缓存代码等。
- 是个抽象概念 / 规范，不同的 JDK 版本实现也会不同。
  - JDK 6 及之前，方法区有永久代来实现，认为效果不好，容易OOM，于是开始放入本地内存的计划。
  - JDK 7，将原本放在永久代的字符串常量池、静态变量等移出，此时运行时常量池还在永久代中。
  - JDK 8+，彻底废除了永久代的概念，使用元空间来代替，并将 JDK 7 中永久代剩余内容全部移到元空间中，使用元空间来实现方法区，元空间使用本地内存。具有独立 GC 机制，更加高效。

##### 	5.1 运行时常量池

- 当类被加载时，存放类中的字面量与符号引用，由符号引用翻译出来的直接引用也存储在运行时常量池
- 每个类或接口都有自己的运行常量池。

#### 6.直接内存

​	NIO 的 `ByteBuffer.allocateDirect()` 分配的堆外内存；不受 JVM GC 管理，但影响 JVM 内存占用。

## Hotpot 虚拟机中对象

### 一、对象的创建

在 HotSpot 虚拟机中，对象的创建流程可分为以下步骤：

**1. 类加载检查**

- 当遇到 `new` 指令时，JVM 首先检查该指令的参数能否在常量池中定位到类的符号引用。
- 检查该类是否已被加载、解析和初始化。若未加载，则触发类加载过程。

**2. 内存分配**

HotSpot 采用两种策略分配内存，具体取决于 Java 堆是否规整：

- 指针碰撞（Bump the Pointer）
  - **适用场景**：堆内存规整（如 Serial、ParNew 等带压缩整理的垃圾收集器）。
  - **原理**：通过移动指针划分空闲内存（`指针 + 对象大小`）。
- 空闲列表（Free List）
  - **适用场景**：堆内存不规整（如 CMS 等基于标记-清除的垃圾收集器）。
  - **原理**：维护一个列表记录可用内存块，分配时从列表中找到足够大的空间。

​	**2.1并发安全优化**

​     多线程环境下，通过两种机制避免竞争：

1. **CAS + 失败重试**：确保更新操作的原子性。
2. TLAB：对象优先在 TLAB 分配，避免同步开销；若 TLAB 不足，再通过采用上面的 CAS 方法内存分配。

**3. 初始化零值**

- 将对象除对象头外的内存空间初始化为零值（如 `int`→0，`boolean`→false）。
- 确保对象实例变量在 Java 代码中可以不赋初始值就直接使用。

**4. 设置对象头（Header）**

​	对象头包含两部分：

1. **Mark Word**：存储哈希码、GC 分代年龄、锁状态等（详见下文）。
2. **Klass Pointer**：指向方法区中的类元数据（开启压缩指针后占 4 字节，否则 8 字节）。

**5. 执行 `<init>` 方法**

- 调用对象的构造方法（`<init>`），按代码初始化成员变量，此时一个真正可用的对象才创建出来了。

### 二、对象创建后在堆中内存分配过程

1. #### 首先 new 一个对象，并判断Eden区内存空间是否足够：

   1. 若够，则直接在Eden区中分配
   2. 若不够，则Minor GC 一次，并判断Eden区空间是否足够：
      1. 若够，那么就在Eden区中分配对象，
      2. 若不够，就判断老年代区是否足够：
         - 若够，那么对象直接进入老年代
         - 若不够，则Full GC 一次，并判断老年代空间是否足够：
           - 若够，那么就在老年代中分配对象，
           - 若不够，则抛出OOM异常

2. #### **Minor GC 与 Full GC**



### 三、对象的内存布局

​	对象在堆中的存储布局分为三部分：	

**1. 对象头（Header）**

- **Mark Word | 标记字段**（8 字节，64 位系统）：

  | **锁状态** |            **存储内容**            |
  | :--------: | :--------------------------------: |
  |    无锁    | 哈希码、分代年龄、偏向锁标志（01） |
  |   偏向锁   |   线程ID、Epoch、分代年龄（101）   |
  |  轻量级锁  |     指向栈中锁记录的指针（00）     |
  |  重量级锁  | 指向监视器（Monitor）的指针（10）  |
  |  GC 标记   |              空（11）              |

- **Klass Pointer | 类型指针**：指向类元数据的指针，JVM 通过这个指针确定这个对象是哪个类的实例。

**2. 实例数据（Instance Data）**

- 存储对象的实际字段（包括父类继承的字段）。
- 字段排列顺序受虚拟机分配策略和字段类型影响：
  - 相同宽度的字段分配在一起（如 `long`/`double` → `int` → `short` → `char` → `byte` → `boolean`）。
  - 子类字段可能插入父类字段的间隙以节省空间。

**3. 对齐填充（Padding）**

- HotSpot 要求对象大小必须是 8 字节的整数倍，不足时填充对齐。

### 四、对象的访问定位

Java 程序通过栈上的 **reference** 访问堆中对象，主流方式有两种：

**1. 句柄访问**

1. Java 堆中会划分出一块内存作为句柄池，栈帧中的局部变量表里的 `reference` 存储的对象的句柄地址。
2. 句柄中包含了 到对象实例数据 和 到对象类型数据 的指针。
3. 优缺点：
   - 优点：GC 时只需更新句柄池中的指针，`reference` 无需修改。
   - 缺点：多一次间接访问，性能略低。

**2. 直接指针（HotSpot 采用）**

1. reference 直接存储这对象的地址，对象头中包含类元数据指针。

2. 优缺点：

   - 优点：访问速度快（减少一次指针跳转）。

   - 缺点：GC 时需更新所有 `reference`（如对象移动）。


------

## JVM 垃圾回收

### 内存分配原则

**1. 对象优先在 Eden 区分配**

- **新生代（Young Generation）** 分为 Eden 区和两个 Survivor 区（S0/S1）。
- **绝大多数新对象** 首先分配在 Eden 区。
- **TLAB（Thread Local Allocation Buffer）优化**：每个线程在 Eden 区拥有私有分配缓冲区，避免多线程竞争。

**2. 大对象直接进入老年代**

- **大对象定义**：占用连续内存空间的对象（如长数组、大字符串）。
- **分配规则**：通过 `-XX:PretenureSizeThreshold` 参数设置阈值（默认 0，表示由 JVM 决定），超过阈值的大对象直接进入老年代。
- **目的**：避免大对象在 Eden 区频繁复制，降低 GC 开销。

**3. 长期存活对象晋升老年代**

- **对象年龄计数器**：对象每在 Survivor 区存活一次 Minor GC，年龄 +1。
- **晋升阈值**：默认 15 岁（通过 `-XX:MaxTenuringThreshold` 调整），达到阈值后晋升老年代。

**4. 动态对象年龄判定**

- **规则**：若 Survivor 区中 **相同年龄的所有对象大小总和 > Survivor 空间的一半**，则年龄 ≥ 该值的对象直接晋升老年代。
- **目的**：避免 Survivor 区空间不足导致频繁 GC。

**5. 空间分配担保**

- Minor GC 前检查：老年代剩余空间是否 > 新生代所有对象总大小。
  - 若成立，则 Minor GC 安全。
  - 若不成立，检查 `-XX:HandlePromotionFailure` 参数（JDK 7+ 默认忽略）：
    - 若允许担保失败，继续 Minor GC。
    - 否则触发 Full GC。

### 死亡对象判断方法

1. #### 引用计数法：

   给对象中添加一个引用计数器，过程如下：

   - 每当有一个地方引用它，就 + 1
   - 每当一个引用失效了，就 - 1
   - 任何时候，当一个计数器为 0 时，代表这个对象不可用

   优缺点：实现简单且高效，但是不流行的原因时，难以解决对象间循环引用 A->B->A 的问题

2. #### 可达性分析算法：

   - 设置称为 `GC ROOTs` 的对象作为起点，
   - 从  `GC ROOTs` 向下开始搜索，节点走过的路径叫做引用链，
   - 若一个对象到  `GC ROOTs` 没有任何的引用链，证明此对象是不可用的，要回收。

3. #### GC ROOTs 可以是以下的对象：

   - 虚拟机栈(栈帧中的局部变量表)中引用的对象
   - 本地方法栈(Native 方法)中引用的对象
   - 方法区中类静态属性引用的对象
   - 方法区中常量引用的对象
   - 所有被同步锁持有的对象
   - JNI（Java Native Interface）引用的对象

4. #### 两次标记

   1. **第一次标记**：通过可达性分析，标记不可达对象。

   2. **筛选**：检查对象是否重写了 `finalize()` 且未被调用过。

      - 若未重写或已调用过，直接回收。
      - 若重写且未调用，放入一个队列中。

   3. **第二次标记**：执行 `finalize()` 后再次进行可达性分析。

      - 若仍不可达，则回收。

      - 若“复活”，则移出回收列表。

5. #### 引用类型总结：四种引用类型

   - 强引用：Java 中普遍的对象，其实就是程序代码中的引用赋值，是生活必需品，GC 是绝对不会回收它的，内存不足宁愿抛出 OOM 的报错。除非显示设为 null

     ~~~java
     // 强引用
     String strongReference = new String("abc");
     ~~~

   - 软引用：`SoftReference`，类似可有可无的生活用品，内存空间足够，就不会收回它，否则会收回。

        好处：软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止OOM等。

     ~~~java
     // 软引用
     String str = new String("abc");
     SoftReference<String> softReference = new SoftReference<String>(str);
     ~~~

   - 弱引用：`WeakReference`，也类似可有可无的生活用品，与软引用相比，生命周期更短，一旦被GC发现了它的存在，就会被回收。

     ~~~java
     // 弱引用
     String str = new String("abc");
     WeakReference<String> weakReference = new WeakReference<>(str);
     str = null; //str变成软引用，可以被收集
     ~~~

   - 虚引用：`PhantomReference`，形同虚设，任何时候都可以被GC，主要用来跟踪对象回收状态。

     ~~~java
     String str = new String("abc");
     ReferenceQueue queue = new ReferenceQueue();
     // 创建虚引用，要求必须与一个引用队列关联
     PhantomReference pr = new PhantomReference(str, queue);
     ~~~

### 垃圾收集算法

- #### **1.标记-清除算法：**

  **原理：**

  1. **标记阶段**：从 GC Roots 出发，标记所有可达对象。
  2. **清除阶段**：遍历堆内存，回收未被标记的对象。

  **特点：**

  - ✅ **优点**：实现简单，适用于存活对象较多的场景（如老年代）。
  - ❌ 缺点：
    - 产生内存碎片（需配合内存整理）。
    - 效率较低（需两次遍历内存）。

- **内存碎片：**指内存中存在的 **不连续的小块空闲空间**，这些空间总容量可能足够分配新对象，但由于 **不连续** 而无法被有效利用。就像零零散散的拼图，合在一起的面积够大，但是无法拼出一个图案。

- #### **2.标记-复制算法：**

  ​     **原理：**

  1. 将内存分为 **Eden 区** 和 **两块 Survivor 区**（S0/S1）。
  2. 将 Eden 和 S0 区的存活对象复制到 S1 区，然后清空 Eden 和 S0。

  **特点：**

  - ✅ 优点：
    - 无内存碎片。
    - 高效（仅复制存活对象）。
  - ❌ 缺点：
    - 浪费 10% 内存（Survivor 区默认 8:1:1）。
    - 对象存活率高时效率下降。

- #### **3.标记-整理算法：**

  ​     **原理：**

  1. **标记阶段**：从 GC-ROOTs 出发，标记所有可达对象
  2. **整理阶段**：将存活对象向内存一端移动，清理边界外内存。

  **特点：**

  - ✅ **优点**：避免内存碎片，适合老年代。
  - ❌ **缺点**：对象移动开销大（需更新引用地址）

- #### **4.分代收集算法：**

  **核心思想：**

  - **根据对象生命周期** 将堆分为新生代（Young Generation）和老年代（Old Generation）。
  - 不同代采用不同算法：
    - **新生代**：复制算法（对象存活率低）。
    - **老年代**：标记-清除或标记-整理（对象存活率高）。

  **工作流程：**

  - 新生代 Minor GC：
    - Eden 区满时触发，存活对象复制到 Survivor 区。
    - 年龄达到阈值（默认 15）后晋升老年代。
  - 老年代 Full GC：
    - 老年代空间不足时触发，采用标记-清除/整理算法。

### 垃圾收集器

1. #### Serial 收集器 （串行收集）

   - 定义：新生代收集器，单线程并发工作，在GC时，会暂停其它所有工作线程。
   - 算法：采用标记-复制算法
   - 优缺点：
     - 与其他单线程收集器相比，简单而高效，适用于 Client 模式
     - 但是给用户带来不好体验

2. #### ParNew 收集器

   - 定义：新生代收集器，多线程并行工作，Serial 收集器的多线程版本
   - 算法：采用标记-复制算法

3. #### Parallel Scavenge 收集器 (并行收集)

   - 定义：新生代收集器，多线程并行工作，重点关注吞吐量（高效的利用CPU）
   - 算法：新生代采用标记-复制算法
   - 特点：JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old

4. #### Serial Old 收集器

   - Serial 的老年代版本，老年代收集器，使用 标记-整理算法
   - 主要用途：
     - 在JDK 5 及之前，搭配 Parallel Scavenge 收集器使用
     - 作为 CMS 收集器的后备方案

5. #### Parallel Old 收集器

   - Parallel Scavenge 的老年代版本，使用多线程和标记-整理算法。

6. #### CMS 收集器(Concurrent Mask Sweep)

   - 意义：第一款真正意义上的并发收集器，让GC线程和用户线程同时工作，重点关注用户体验(以获取最短回收停顿时间为目标)
   - 定义：老年代专用，标记-清除算法，低延迟但是有内存碎片
   - 过程：
     - 初始标记：标记GC Roots直接关联对象
     - 并发标记：进行GC Roots Tracing
     - 重写标记：修改并发标记因用户程序变动的内容
     - 并发清除：清除不可达对象回收空间，同时有新垃圾产生，留着下次清理称为浮动垃圾
   - 浮动垃圾：并发清除阶用户线程还在运行，这段时间就可能会产生新垃圾，新垃圾无法在此次GC中被清除，只好等到下次清理，所以叫做浮动垃圾。
   - 优缺点：
     - 优点：并发收集、低停顿
     - 缺点：
       - 对 CPU 资源敏感；
       - 无法处理浮动垃圾；
       - 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

7. #### G~1~ 收集器（Garbage-First）

   - 定义：G1收集器是JDK9+的默认垃圾收集器，定位为面向服务端的全局垃圾回收器。设计目标是在可控的停顿时间内实现高吞吐量，适合大内存和多核环境。
   - 核心设计思想：
     - 分区（Region）模型：
       - 将堆内存划分为多个大小相等的区域
       - 新生代/老年代不再物理隔离，而是逻辑上由不同的 Region 组成
     - Garbage-Fitst 原则：
       - 优先回收垃圾比例最高的 Region 区域，提高垃圾回收效率
     - 可预测停顿模型：
       - 可以设置目标停顿时间，动态调整回收策略
   - 执行过程：
     - **初始标记**：标记以下GC Roots能够关联的对象，并且修改TAMS的值，需要暂停用户线程
     - **并发标记**：从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行
     - **最终标记**： 修正在并发标记阶段因为用户程序的并发执行导致变动的数据，需暂停用户线程
     - **筛选回收**：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划

8. #### ZGC 收集器

   - 定义：JDK11+引入的垃圾收集器，不再由新老年代的概念，而是一个个的page，同时GC操作还会对Page进行压缩，所以没有内存碎片的问题了，只能在Linux的64位系统上使用，用的少。

-----

## 类加载过程

#### 类的生命周期

类从被加载到虚拟机内存中到卸载出内存为止，生命周期可以概括为5或7个阶段：

- #### **加载->连接(验证->准备->解析)->初始化->使用->卸载**

#### 类加载详细过程

Class 文件需要加载到虚拟机中才可以运行和使用，加载分为三步：加载->连接->初始化

- #### 加载：

  - 将编译好的classFile文件以字节流的形式通过类加载器加载加载到我们的内存中去
  - 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在堆中生成一个 `java.lang.Class` 对象，作为方法区中数据的访问入口

- #### 验证：

  - 文件格式检验：
  - 元数据检验：是否符合Java的语言规范
  - 字节码检验：确定程序符合语义，符合逻辑
  - 符号引用检验：确保下一步的解析能够正常运行

- #### 准备：

  - 将类的静态变量分配内存，并赋值

- #### 解析：

  - 将运行时常量池中的符号引用替换为直接引用

- #### 初始化：

  - 执行初始化方法 `<clint>()` 方法的过程，是类加载的最后一步
  - 会初始化静态变量的值
  - 初始化静态代码块，如果存在父子静态代码块，先初始化父类的，然后再初始化子类的。

## 类加载器

### 你知道的类加载器有哪些？ 

- **`BootstrapClassLoader`(启动类加载器)**：
  - 作用：主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
  - 定位：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，

- **`ExtensionClassLoader`(扩展类加载器)**：
  - 作用：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
  - 定位：第二层，用于加载JDK扩展功能（如加密解密、XML解析等），由Java实现。

- **`AppClassLoader`(应用程序类加载器)**：
  - 作用：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。
  - 定位：第三层，是默认的**线程上下文类加载器**，由Java实现。
- `CustomClassLoader` **(自定义类加载器)**：
  - 作用：通过继承`ClassLoader`类的并自重写 `FindClass()` 方法，来自定义加载器。
    - 打破双亲委派： 实现热部署、模块化加载等特殊需求
    - 隔离加载：不同加载器加载的类即使全限定名相同也被视为不同类
    - 特殊来源加载：从网络、加密文件、数据库等非标准位置加载类

### 讲讲双亲委派机制

#### 执行流程

1. 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
2. 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
3. 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。
4. 如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常。

#### 双亲委派模型的优点

|     **优势**     |                           **说明**                           |
| :--------------: | :----------------------------------------------------------: |
|    **安全性**    | 防止核心API被篡改（如自定义`java.lang.Object`会被Bootstrap加载器优先加载） |
| **避免重复加载** |   保证类全局唯一性（相同类名不同加载器加载的类视为不同类）   |
|   **资源隔离**   |             不同层级的加载器负责不同范围的类加载             |

#### 打破双亲委派机制

|       **方法**        |                  **实现方式**                  |       **典型案例**       |
| :-------------------: | :--------------------------------------------: | :----------------------: |
| **重写`loadClass()`** | 直接覆盖双亲委派逻辑（不推荐，破坏JVM稳定性）  |   Tomcat早期的类加载器   |
| **线程上下文加载器**  | 通过`Thread.setContextClassLoader()`指定加载器 |      JDBC SPI、JNDI      |
|    **模块化设计**     |    每个模块使用独立类加载器，自定义加载顺序    | OSGi、Spring Boot FatJar |

#### 打破双亲委派模型会引发的问题

- **安全风险**：可能绕过核心库的保护机制
- **类冲突**：相同类被不同加载器加载导致`ClassCastException`
- **内存泄漏**：卸载加载器需确保无残留引用

## JMM

- #### 定义：JMM定义了Java程序中的变量、线程如何和主存以及工作内存进行交互的规则。它主要涉及到多线程环境下的共享变量可见性、指令重排等问题。

|  **特性**  |          **含义**          |            **实现机制**             |
| :--------: | :------------------------: | :---------------------------------: |
| **原子性** |        操作不可中断        |    `synchronized`、`Lock`、`CAS`    |
| **可见性** | 线程修改后其他线程立即可见 | `volatile`、`synchronized`、`final` |
| **有序性** |       禁止指令重排序       |  `volatile`、`happens-before`规则   |

- 8个同步操作：

  - lock(锁定)、unlock(解锁)、read(读取)、load(载入)、
  - use(使用)、assign(赋值)、store(存储)、write(写入) 

- #### Happens-Before 原则

  - 被用来阐述操作之间的内存可见性，确保多线程程序的正确性和一致性，底层依靠内存屏障来实现。

  - 常见规则：

    - **程序顺序规则**：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；
    - **解锁规则**：解锁 happens-before 于加锁；
    - **volatile 变量规则**：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。
    - **传递规则**：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；
    - **线程启动规则**：Thread 对象的 `start()`方法 happens-before 于此线程的每一个动作。

    
